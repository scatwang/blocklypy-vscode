import { DeviceNotificationMessage } from '../spike/messages/device-notification-message';
import { TunnelNotificationMessage } from '../spike/messages/tunnel-notification-message';
import { TunnelRequestMessage } from '../spike/messages/tunnel-request-message';
import { pack } from '../spike/utils/cobs';
import { DeviceNotificationMessageType } from '../spike/utils/device-notification-parser';
import { TunnelMessageType } from '../spike/utils/tunnel-notification-parser';
import {
    decodeMessageRaw,
    encodeDebugMessageRaw,
    encodePlotMessageRaw,
    PIPDebugNotifyMessage,
    PIPMessageType,
    PIPPlotNotifyMessage,
    VarType,
} from './instrumentation-protocol';

describe('instrumentation-protocol debug message', () => {
    it('encodes and decodes debug messages correctly', () => {
        const filename = 'main.py';
        const line = 42;
        const variables = [
            { name: 'xxx', type: VarType.Int, value: 123 },
            { name: 'yyy', type: VarType.Float, value: 3.14 },
            { name: 'msg', type: VarType.String, value: 'hello' },
            { name: 'flag', type: VarType.Bool, value: true },
        ];

        const encoded = encodeDebugMessageRaw({
            Id: PIPMessageType.DebugNotify,
            filename,
            line,
            variables,
        } satisfies PIPDebugNotifyMessage);
        const decoded = decodeMessageRaw(encoded) as PIPDebugNotifyMessage;

        expect(decoded.filename).toBe(filename);
        expect(decoded.line).toBe(line);
        expect(decoded.variables.length).toBe(variables.length);

        checkCompareDebugVariable(variables, decoded);
    });

    it('encodes and decodes debug messages correctly even with garbag', () => {
        const filename = 'main.py';
        const line = 42;
        const variables = [{ name: 'xxx', type: VarType.Int, value: 123 }];

        const encoded = encodeDebugMessageRaw({
            Id: PIPMessageType.DebugNotify,
            filename,
            line,
            variables,
        } satisfies PIPDebugNotifyMessage);
        // add garbage before and check if it still decodes
        const garbage = new Uint8Array([0x05, 0x03, 0x05, 0xff, 0x12, 0x34]);
        const combined = new Uint8Array(garbage.length + encoded.length);
        combined.set(garbage);
        combined.set(encoded, garbage.length);
        // console.log('Combined with garbage:', combined);
        const decoded = decodeMessageRaw(encoded) as PIPDebugNotifyMessage;

        expect(decoded.filename).toBe(filename);
        expect(decoded.line).toBe(line);
        expect(decoded.variables.length).toBe(variables.length);

        checkCompareDebugVariable(variables, decoded);
    });

    it('encodes and decodes plot messages correctly', () => {
        const metrics = [{ name: 'yaw', value: 42.1 }];
        const message = {
            Id: PIPMessageType.PlotNotify,
            values: metrics,
        } satisfies PIPPlotNotifyMessage;

        const encoded = encodePlotMessageRaw(message);
        const decoded = decodeMessageRaw(encoded) as PIPPlotNotifyMessage;

        expect(decoded.Id).toBe(PIPMessageType.PlotNotify);
        expect(decoded.values.length).toBe(metrics.length);
        for (let i = 0; i < metrics.length; i++) {
            expect(decoded.values[i].name).toEqual(metrics[i].name);
            expect(decoded.values[i].value).toBeCloseTo(metrics[i].value);
        }
    });

    it('encodes and decodes plot messages with multiple values correctly', () => {
        const metrics = [
            { name: 'time', value: 1.23 },
            { name: 'value', value: 4.56 },
        ];
        const message = {
            Id: PIPMessageType.PlotNotify,
            values: metrics,
        } satisfies PIPPlotNotifyMessage;

        const encoded = encodePlotMessageRaw(message);
        const decoded = decodeMessageRaw(encoded) as PIPPlotNotifyMessage;

        expect(decoded.Id).toBe(PIPMessageType.PlotNotify);
        expect(decoded.values.length).toEqual(metrics.length);
        for (let i = 0; i < metrics.length; i++) {
            expect(decoded.values[i].name).toEqual(metrics[i].name);
            expect(decoded.values[i].value).toBeCloseTo(metrics[i].value);
        }
    });

    it('encodes and decodes DeviceNotificationMessage message correctly', () => {
        const message = new DeviceNotificationMessage([
            {
                type: DeviceNotificationMessageType.Battery,
                batteryLevel: 85,
            },
            {
                type: DeviceNotificationMessageType.ImuValues,
                faceUp: 1,
                yawFace: 2,
                yaw: 0x0101,
                pitch: 0x0102,
                roll: 0x0103,
                accX: 0x0104,
                accY: 0x0105,
                accZ: 0x0106,
                gyroX: 0x0107,
                gyroY: 0x0108,
                gyroZ: 0x0109,
            },
        ]);

        // use little-endian byte order
        const bytes = new Uint8Array([
            0x3c, // message ID
            2 + 21, // length 2 + 21
            0x00,
            // Battery payload
            0x00, // type
            0x55, // battery level
            // IMU payload
            0x01, // type
            0x01, // face up
            0x02, // yaw face
            ...[0x01, 0x01],
            // pitch (int16 LE)
            ...[0x02, 0x01],
            // roll (int16 LE)
            ...[0x03, 0x01],
            // accX (int16 LE)
            ...[0x04, 0x01],
            // accY (int16 LE)
            ...[0x05, 0x01],
            // accZ (int16 LE)
            ...[0x06, 0x01],
            // gyroX (int16 LE)
            ...[0x07, 0x01],
            // gyroY (int16 LE)
            ...[0x08, 0x01],
            // gyroZ (int16 LE)
            ...[0x09, 0x01],
        ]);

        // encode is done above
        const encoded = bytes;
        // const parsedMessage = DeviceNotificationMessage.fromBytes(bytes);
        const decoded = decodeMessageRaw(encoded);
        expect(decoded).toBeInstanceOf(DeviceNotificationMessage);
        const decoded1 = decoded as DeviceNotificationMessage;
        expect(decoded1.payloads.length).toBe(message.payloads.length);
        expect(decoded1.payloads[0]).toEqual(message.payloads[0]);
        expect(decoded1.payloads[1]).toEqual(message.payloads[1]);
    });

    it('encodes and decodes tunnel message correctly', () => {
        const message = new TunnelRequestMessage([
            {
                type: TunnelMessageType.WeatherAtOffsetRequest,
                correlationId: 42,
                days: 3,
                hours: 6,
                location: 'Test',
            },
        ]);
        const encoded = message.serialize();
        // const decoded = TunnelNotificationMessage.fromBytes(encoded);
        const decoded = decodeMessageRaw(encoded);
        expect(decoded).toBeInstanceOf(TunnelNotificationMessage);
        const decoded1 = decoded as TunnelNotificationMessage;
        expect(decoded1.tunnelData?.length).toBe(message.tunnelData?.length);
        expect(decoded1.tunnelData?.[0]).toEqual(message.tunnelData?.[0]);
    });

    it('decodes binarystring PlotNotify correctly without cobs', () => {
        // Example from
        const data = "b'r\x02humidity\x00\x00\x00pBtemp\x00\x00\x00\xbcA'";
        const buffer = decodePythonBytesToBuffer(data);
        expect(buffer).toBeInstanceOf(Buffer);
        expect(buffer.length).toBe(24);
        expect(buffer[0]).toBe(PIPMessageType.PlotNotify);
    });

    it('decodes binarystring PlotNotify correctly without cobs', () => {
        // Example from
        const data = "b'\x72\x02humidity\x00\x00\x00\x70\x42temp\x00\x00\x00\xbc\x41'";
        const buffer = decodePythonBytesToBuffer(data);
        const message = decodeMessageRaw(buffer) as PIPPlotNotifyMessage;
        expect(message.Id).toBe(PIPMessageType.PlotNotify);
        expect(message.values.length).toBe(2);
        expect(message.values[0]).toEqual({ name: 'humidity', value: 60.0 });
        expect(message.values[1]).toEqual({ name: 'temp', value: 23.5 });
    });

    // it('decodes binarystring PlotNotify correctly with cobs', () => {
    //     // Example from
    //     const data =
    //         "b'\xaf\x71\x08\x6b\x76\x6e\x6a\x67\x6a\x77\x7a\x00\x00\x0a\x73\x41\x77\x66\x6e\x73\x00\x00\x06\xbf\x42\x02'";
    //     const buffer = decodePythonBytesToBuffer(data);
    //     const message = decodeMessage(buffer) as PIPPlotNotifyMessage;
    //     expect(message.Id).toBe(PIPMessageType.PlotNotify);
    //     expect(message.values.length).toBe(2);
    //     expect(message.values[0]).toEqual({ name: 'humidity', value: 60.0 });
    //     expect(message.values[1]).toEqual({ name: 'temp', value: 23.5 });
    // });

    it('decodes binarystring DebugNotify message correctly', () => {
        const data =
            "b'pmain.py\x00*\x00\x04\x00x\x00{\x00\x00\x00\x01y\x00\xc3\xf5H@\x02msg\x00hello\x00\x03flag\x00\x01'";
        const buffer = decodePythonBytesToBuffer(data);
        const buffer1 = pack(buffer);
        console.log('COBS packed buffer:', buffer1);

        expect(buffer).toBeInstanceOf(Buffer);
        expect(buffer.length).toBe(44);
        expect(buffer[0]).toBe(0x70);

        const message = decodeMessageRaw(buffer) as PIPDebugNotifyMessage;
        expect(message.filename).toBe('main.py');
        expect(message.line).toBe(42);
        expect(message.variables.length).toBe(4);
        expect(message.variables[0]).toEqual({
            name: 'x',
            type: VarType.Int,
            value: 123,
        });
        expect(message.variables[1].name).toBe('y');
        expect(message.variables[1].type).toBe(VarType.Float);
        expect(message.variables[1].value as number).toBeCloseTo(3.14, 6);
    });

    // it('decodes cobs encoded debug message correctly', () => {
    //     const data =
    //         "b'\x0bpmain.py\x04*\x04\x04\x04x\x04{\x03\x03W\x04y\xaf\xc3\xf5H@\x06msg\x08hello\x08\x03flagW\x03\x02'";
    //     const buffer = decodePythonBytesToBuffer(data);
    //     console.log('COBS encoded buffer:', buffer);
    //     const buffer1 = unpack(buffer);
    //     console.log('COBS unpacked buffer:', buffer1);

    //     const message = decodeMessage(buffer) as PIPDebugNotifyMessage;
    //     expect(message.filename).toBe('main.py');
    //     expect(message.line).toBe(42);
    //     expect(message.variables.length).toBe(4);
    //     expect(message.variables[0]).toEqual({
    //         name: 'x',
    //         type: VarType.Int,
    //         value: 123,
    //     });
    //     expect(message.variables[1].name).toBe('y');
    //     expect(message.variables[1].type).toBe(VarType.Float);
    //     expect(message.variables[1].value as number).toBeCloseTo(3.14, 6);
    // });
});

function checkCompareDebugVariable(
    variables: (
        | { name: string; type: VarType; value: number }
        | { name: string; type: VarType; value: string }
        | { name: string; type: VarType; value: boolean }
    )[],
    decoded: {
        filename: string;
        line: number;
        variables: {
            name: string;
            type: VarType;
            value: number | string | boolean | null;
        }[];
    },
) {
    for (let i = 0; i < variables.length; i++) {
        const orig = variables[i];
        const dec = decoded.variables[i];
        expect(dec.name).toBe(orig.name);
        expect(dec.type).toBe(orig.type);
        if (orig.type === VarType.Float) {
            expect(dec.value as number).toBeCloseTo(orig.value as number, 6);
        } else {
            expect(dec.value).toBe(orig.value);
        }
    }
}

/**
 * Decodes a Python byte string literal (b'...') into a Node.js Buffer.
 * This handles ASCII characters and '\xNN' hex escapes.
 * * @param pythonByteString - The Python byte literal string (without the leading b' and trailing ')
 * @returns A Node.js Buffer containing the decoded bytes.
 */
function decodePythonBytesToBuffer(pythonByteString: string): Buffer {
    // check if it starts with b' and ends with ' and remove them
    if (pythonByteString.startsWith("b'") && pythonByteString.endsWith("'")) {
        pythonByteString = pythonByteString.slice(2, -1);
    }

    // Regular expression to find either:
    // 1. A two-digit hex escape (\xNN)
    // 2. A single non-backslash character (which is treated as a literal ASCII character)
    const regex = /\\x([0-9a-fA-F]{2})|([^\\\s])/g;

    const bytes: number[] = [];
    let match: RegExpExecArray | null;

    while ((match = regex.exec(pythonByteString)) !== null) {
        if (match[1]) {
            // Case 1: Hex escape \xNN found (e.g., \x02, \xbc)
            // match[1] is the two-digit hex string (NN)
            bytes.push(parseInt(match[1], 16));
        } else if (match[2]) {
            // Case 2: Literal character found (e.g., q, t, e, m, p, h, u, m, i, d, y)
            // match[2] is the character string
            bytes.push(match[2].charCodeAt(0));
        } else if (match[0] === '\\') {
            // Handle escaped backslashes (if any, though none in your example)
            bytes.push('\\'.charCodeAt(0));
        }
    }

    // Create a Buffer from the array of byte numbers
    return Buffer.from(bytes);
}

// /**
//  * Decodes a hex or decimal string (space-separated) into a Buffer.
//  * Example: "72 02 68 75 6d 69 64 69 74 79 00 00 00 70 42 74 65 6d 70 00 00 00 bc 41"
//  */
// function decodeHexOrDecimalStringToBuffer(
//     input: string,
//     radix_hex: boolean = true,
// ): Buffer {
//     const bytes = input
//         .trim()
//         .split(/\s+/)
//         .map((part) => parseInt(part, radix_hex ? 16 : 10))
//         .filter((n) => !isNaN(n) && n >= 0 && n <= 255);
//     return Buffer.from(bytes);
// }
